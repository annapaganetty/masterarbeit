```{julia}
include("../src/setup.jl")

update_theme!(
    colormap=:redblue,
    color=3,
    faceplotzscale=1,
    faceplotnpoints=15,
    faceplotmesh=0,
    edgesvisible=true,
    featureedgelinewidth=2.5)
```


# Beispiel quadratische Platte

## Plot der Plattenelemente
```{julia}
WGLMakie.activate!()
xElem = 2
m1 = makequadratcicMesh(p1, xElem)
plotmesh(m1; title="quadratische Platte")
```


```{julia}
using MMJMesh.Geometries
e = element(m1,1)
Ke = zeros(12,12)
jF = jacobian(parametrization(geometry(e)))
        
Hx = MappingFromComponents(btpHx(e)...) # 12 Element Vektor mit Hx Funktionen 
Hy = MappingFromComponents(btpHy(e)...) # 12 Element Vektor mit Hy Funktionen 
∇ξN = MMJMesh.Mathematics.TransposeMapping(jacobian(Hx))
∇ηN = MMJMesh.Mathematics.TransposeMapping(jacobian(Hy))

for (ξ, w) ∈ zip(gaussPoints, gaussWeights)
    # Jacobi matrix ausgewertet an der Stelle ξ
    J = jF(ξ)
    ∇ₓN = (inv(J) * ∇ξN(ξ)) # 2x2 mal 2x12
    ∇yN = (inv(J) * ∇ηN(ξ)) 
    B = [∇ₓN[1,:]', ∇yN[1,:]', ∇ₓN[1,:]'+ ∇yN[1,:]']
    Ke = w * B' * B * det(J)
end
``` 

## Verformung 

Berechnung der Elementsteifigkeitsmatrizen und Lastvektoren, sowie Festlegung der Randbedingungen. Anschließend Berechnung der Verformung

```{julia}
w = plate(m1, p1, "BTP")
```

Ausgabe maximale Verformung und prozentuale Abweichung von der Berechnung nach den Czerny-Tafeln

```{julia}
w_fe = maximum(w[1:3:end])
w_czerny = 5e3 * 8^4 / (31000e6 * 0.2^3) * 0.0152
w_abw = 100 * abs(w_fe - w_czerny) / w_czerny
```

```{julia}
plotwBTP(m1, w; title="Verformung")
```

## Verdrehung ThetaX
```{julia}
plotThetaxBTP(m1, w; title="Verdrehung θx")
```

## Verdrehung ThetaY
```{julia}
plotThetayBTP(m1, w; title="Verdrehung θy")
```

## Schnittgrößen Plotten 

```{julia}
post = m1.data[:post]

for i = 1:nelements(m1)
    ff = face(m1, i)
    we = post(ff, :mx)
    println("mx[", i, "] = ", we)
    # println(typeof(we))
end
```

### Mx

```{julia}
function makeMoment(result, m)
    post = m.data[:post]
    return face -> begin
        rElement = post(face, result)
        println("mx[", face, "] = ", rElement)
        return rElement
    end
end

makeMoment(:mx, m1)
# function plotMx(
#     m, result;
#     w=600, h=600, title="",
# )
#     fig = mkfig3d(title=title)
#     mplot!(
#         m, makeMoment(result,m),
#         nodewarp = nothing,
#         faceplotnpoints = 15, colorrange = (-10, 10),
#         faceplotzscale = 1000,
#         edgesvisible = false, 
#         edgelinewidth = 0.2,
#         nodesvisible=false,
#         featureedgelinewidth = 0.5,
#         color=5,
#         colormap = Makie.theme(:colormap),
#         limits = (nothing, nothing, nothing)
#     )
#     fig
# end
# plotMx(m1, :mx,title = "Biegemoment mx")
```


```{julia}
plotrBTP(m1, :mx, "Biegemoment mx", (-7, 7), nodal=false, a3d=true)
```

### My
```{julia}
plotrBTP(m1, :my, "Biegemoment my", (-7, 7), nodal=false, a3d=true)
```

### Mxy
```{julia}
plotrBTP(m1, :mxy, "Biegemoment mxy", (-7, 7), nodal=false, a3d=true)
```

```{julia}
plotrBTP(m1, :qx, "qx", (-3, 3), nodal=false, a3d=true)
```


-----------------------------------

```{julia}
V = [0 a a 0; 0 0 b b]
H4 = hermiteelement(V;conforming=true)
Ke = weakform(H4,"standard")
```


```{julia}
pKe(Ke)
```