```{julia}
include("../src/setup.jl")
```

# Patch Test

```{julia}
a = 20 
b = 10 
```

Parameter Platte 
```{julia}
p3 = @var Params()
p3.lx = 2*a
p3.ly = 2*b
p3.q = 10
p3.ν = 0
p3.h = 1
p3.E = 1000;
```

## Plot der Plattenelemente
```{julia}
WGLMakie.activate!()
mPatchOG = makequadrilateralMesh(p3)
plotmesh(mPatchOG;title="Patch Test")
```

```{julia}
w = plate(mPatchOG, p3, "BTP")
```

```{julia}
plotwBTP(mPatchOG, w; title="Verformung")
```

```{julia}
NN = 3 * nnodes(mPatchOG)
nb = collect(mPatchOG.groups[:boundarynodes])
ni = [i for i in 1:nnodes(mPatchOG) if i ∉ nb]
adofs = idxDOFs(ni, 3)
NNa = length(adofs)
ei(n, i) = [j == i ? 1 : 0 for j ∈ 1:n]
```

## Basisfunktionen Hx auf Patch Test Netz
```{julia}
plotBasisfunc(mPatchOG, makeThetaxBTP(ei(NN, adofs[9])); title="Verformung")
```


```{julia}
fig2 = Figure(;size = (700,700),linewidth = 0.5,fontsize = 12,font="calibri",title="Hx Funktionen auf Patch Test Netz")
for i = 1:4
    for j = 1:3
        if i == 1
            n = j
        elseif i == 2
            n = j + 3
        elseif i == 3
            n = j + 6
        elseif i == 4
            n = j + 9
        end
        ax = Axis3(fig2[i,j], aspect=:data, title = "", viewmode=:stretch, perspectiveness=0.2, limits=(nothing, nothing, nothing), protrusions=1,elevation = 0.05)
        hidedecorations!(ax)
        hidespines!(ax)
        mplot!(mPatchOG, makeThetaxBTP(ei(NN, adofs[n])),
            faceplotzscale = 5,
            faceplotmesh = 5,
            edgesvisible = false, 
            edgelinewidth = 0.2,
            nodesvisible = false,
            featureedgelinewidth = 0.5,
            color = 5,
            colorrange = Makie.automatic,
            colormap=Makie.theme(:colormap),
            limits = (nothing, nothing, nothing))
    end
end
fig2
```

# regelmäßiges Netz

## Plot der Plattenelemente
```{julia}
WGLMakie.activate!()
mRegel = makerectMesh(p3, 4, 2)
plotmesh(mRegel;title="Patch Test")
```

```{julia}
w = plate(mRegel, p3, "BTP")
```

```{julia}
plotwBTP(mRegel, w; title="Verformung")
```

```{julia}
NN2 = 3 * nnodes(mRegel)
nb2 = collect(mRegel.groups[:boundarynodes])
ni2 = [i for i in 1:nnodes(mRegel) if i ∉ nb]
adofs2 = idxDOFs(ni2, 3)
NNa2 = length(adofs2)
ei(n, i) = [j == i ? 1 : 0 for j ∈ 1:n]
```

## Basisfunktionen Hx auf Patch Test Netz
```{julia}
plotBasisfunc(mRegel, makeThetaxBTP(ei(NN2, adofs2[1])); title="Verformung")
```

```{julia}
plotBasisfunc(mRegel, makeThetaxBTP(ei(NN2, adofs2[11])); title="Verformung")
```

```{julia}
plotBasisfunc(mRegel, makeweBTP(ei(NN2, adofs2[7])); title="Verformung")
```

```{julia}
plotBasisfunc(mRegel, makeweBTP(ei(NN2, adofs2[10])); title="Verformung")
```


```{julia}
fig3 = Figure(;size = (700,700),linewidth = 0.5,fontsize = 12,font="calibri",title="Hx Funktionen auf regelmäßigem Netz")
for i = 1:4
    for j = 1:3
        if i == 1
            n = j
        elseif i == 2
            n = j + 3
        elseif i == 3
            n = j + 6
        elseif i == 4
            n = j + 9
        end
        ax = Axis3(fig3[i,j], aspect=:data, title = "", viewmode=:stretch, perspectiveness=0.2, limits=(nothing, nothing, nothing), protrusions=1,elevation = 0.05)
        hidedecorations!(ax)
        hidespines!(ax)
        mplot!(mRegel, makeThetaxBTP(ei(NN2, adofs2[n])),
            faceplotzscale = 5,
            faceplotmesh = 5,
            edgesvisible = false, 
            edgelinewidth = 0.2,
            nodesvisible = false,
            featureedgelinewidth = 0.5,
            color = 5,
            colorrange = Makie.automatic,
            colormap=Makie.theme(:colormap),
            limits = (nothing, nothing, nothing))
    end
end
fig2
```